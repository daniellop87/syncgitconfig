#!/usr/bin/env bash
# syncgitconfig-run — ejecuta una pasada: YAML → staging → repo → commit/push
set -euo pipefail
umask 022

# Carga comunes
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=/opt/syncgitconfig/lib/common.sh
. "$SCRIPT_DIR/../lib/common.sh"

BYPASS_COOLDOWN=0
SEED_MODE=0

usage() {
  cat <<'USAGE'
Uso: syncgitconfig-run [--no-cooldown] [--seed]

  --no-cooldown  Ejecuta ignorando la ventana de cooldown configurada.
  --seed         Fuerza snapshot inicial (implica --no-cooldown).
USAGE
}

parse_args() {
  local unknown=()
  while (($#)); do
    case "$1" in
      --no-cooldown)
        BYPASS_COOLDOWN=1
        ;;
      --seed)
        SEED_MODE=1
        BYPASS_COOLDOWN=1
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        unknown+=("$1")
        ;;
    esac
    shift
  done

  if ((${#unknown[@]})); then
    warn "Argumentos ignorados: ${unknown[*]}"
  fi
}

dest_within_repo_or_die() {
  local dest="$1" repo_root="$2" app="$3"

  if [[ "$dest" == /* ]]; then
    err "apps[$app].dest no puede ser absoluto: $dest"
    exit 1
  fi
  if [[ "$dest" =~ (^|/)[.][.](|/|$) ]]; then
    err "apps[$app].dest contiene '..': $dest"
    exit 1
  fi

  local resolved=""
  if command -v realpath >/dev/null 2>&1; then
    resolved="$(realpath -m "$repo_root/$dest" 2>/dev/null || true)"
  elif command -v python3 >/dev/null 2>&1; then
    resolved="$(python3 - "$repo_root" "$dest" <<'PY'
import os, sys
base = sys.argv[1]
sub = sys.argv[2]
print(os.path.normpath(os.path.join(base, sub)))
PY
)"
  else
    resolved="$repo_root/$dest"
  fi

  case "$resolved" in
    "$repo_root"|"$repo_root"/*) ;;
    *)
      err "apps[$app].dest apunta fuera del repo: $dest"
      exit 1
      ;;
  esac
}

path_dest_from_source() {
  local src="$1"
  local cleaned="$src"
  if [[ "$cleaned" != "/" ]]; then
    cleaned="${cleaned%/}"
  fi
  if [[ -z "$cleaned" || "$cleaned" == "/" ]]; then
    echo "paths/root"
  else
    echo "paths${cleaned}"
  fi
}

main() {
  parse_args "$@"

  require_cmd rsync git install || exit 1
  load_config_yaml "$CONF_PATH"

  acquire_lock_or_exit
  respect_cooldown_or_exit

  ensure_git_repo_ready "$CFG_repo_path" "$CFG_remote_url" "$AUTH_token_file"

  local STAGING_ROOT="$CFG_staging_path/$CFG_host"
  local REPO_HOST_ROOT="$CFG_repo_path/envs/$CFG_env/hosts/$CFG_host"
  mkdir -p "$STAGING_ROOT" "$REPO_HOST_ROOT"

  local staging_changed=0

  RSYNC_FLAGS=(-a --delete --itemize-changes)
  read -r -a EXCL <<<"$(rsync_exclude_flags)"

  local -a EFFECTIVE_PATHS
  EFFECTIVE_PATHS=("${PATHS[@]}")
  local using_watch_paths_as_sources=0
  if (( ${#EFFECTIVE_PATHS[@]} == 0 && ${#WATCH_PATHS[@]} > 0 && ${#APP_NAMES[@]} == 0 )); then
    EFFECTIVE_PATHS=("${WATCH_PATHS[@]}")
    using_watch_paths_as_sources=1
  fi

  if (( ${#APP_NAMES[@]} == 0 && ${#EFFECTIVE_PATHS[@]} == 0 )); then
    err "No se han definido ni 'paths' ni 'watch_paths' en $CONF_PATH."
    err "Añade rutas (bloque 'apps' o 'paths') para generar snapshots."
    exit 1
  fi

  if (( using_watch_paths_as_sources )); then
    log "[INFO] Usando watch_paths como rutas a sincronizar (modo watch_paths)."
  fi

  local staging_pre_has_content=0
  if [[ -n "$(find "$STAGING_ROOT" -mindepth 1 -type f -print -quit 2>/dev/null)" ]]; then
    staging_pre_has_content=1
  fi

  local repo_has_content=0
  if [[ -n "$(find "$REPO_HOST_ROOT" -mindepth 1 -type f -print -quit 2>/dev/null)" ]]; then
    repo_has_content=1
  fi

  local initial_snapshot=0
  if (( staging_pre_has_content == 0 && repo_has_content == 0 )); then
    initial_snapshot=1
  fi
  if (( SEED_MODE )); then
    initial_snapshot=1
  fi

  log "=== RUN $CFG_host ($CFG_env) ==="
  log "Staging: $STAGING_ROOT"
  log "Repo:    $REPO_HOST_ROOT"

  if (( SEED_MODE )); then
    log "[INFO] Ejecutando en modo seed (--seed)."
  fi
  if (( initial_snapshot )); then
    log "[INFO] Snapshot inicial: staging y repo vacíos."
  fi

  mkdir -p "$STAGING_ROOT"

  for ((i=0; i<${#APP_NAMES[@]}; i++)); do
    local app="${APP_NAMES[$i]}" dest="${APP_DESTS[$i]}"
    [[ -z "$dest" ]] && dest="apps/$app"
    APP_DESTS[$i]="$dest"
    dest_within_repo_or_die "$dest" "$REPO_HOST_ROOT" "$app"
    local staged_app_root="$STAGING_ROOT/$dest"
    mkdir -p "$staged_app_root"

    for ((s=0; s<${#SRC_APPIDX[@]}; s++)); do
      if (( SRC_APPIDX[$s] == i )); then
        local src="${SRC_PATHS[$s]}" typ="${SRC_TYPES[$s]}" strip="${SRC_STRIPS[$s]}"
        [[ -z "$strip" ]] && strip="$src"

        if [[ "$typ" == "dir" ]]; then
          if [[ -d "$src" ]]; then
            local rel="/"
            if [[ "$src" == "$strip"* ]]; then
              rel="${src#"$strip"}"; [[ "$rel" == "/" ]] && rel=""
            fi
            local tgt="$staged_app_root/${rel#/}"
            mkdir -p "$tgt"
            local display="$dest"
            [[ -n "${rel#/}" ]] && display="$dest/${rel#/}"
            local rsync_out=""
            rsync_out="$(rsync "${RSYNC_FLAGS[@]}" "${EXCL[@]}" "$src/" "$tgt/" 2>&1)"
            local rsync_rc=$?
            if (( rsync_rc != 0 )); then
              warn "DIR: $src -> $display (rsync falló con código $rsync_rc)"
              if [[ -n "$rsync_out" ]]; then
                while IFS= read -r line; do log "    $line"; done <<<"$rsync_out"
              fi
              continue
            fi
            if [[ -n "$rsync_out" ]]; then
              staging_changed=1
              log "DIR: $src -> $display (cambios)"
              while IFS= read -r line; do log "    $line"; done <<<"$rsync_out"
            else
              log "DIR: $src -> $display (sin cambios)"
            fi
          else
            warn "Directorio no existe: $src"
          fi
        elif [[ "$typ" == "file" ]]; then
          if [[ -f "$src" ]]; then
            local rel="${src#"$strip"}"; rel="${rel#/}"
            local tgt="$staged_app_root/$rel"
            local display="$dest"
            [[ -n "$rel" ]] && display="$dest/$rel"
            if [[ -f "$tgt" ]] && cmp -s "$src" "$tgt"; then
              log "FILE: $src -> $display (sin cambios)"
            else
              install -D -m 0644 "$src" "$tgt"
              staging_changed=1
              log "FILE: $src -> $display (actualizado)"
            fi
          else
            warn "Fichero no existe: $src"
          fi
        else
          warn "Tipo de source desconocido '$typ' en app '$app'"
        fi
      fi
    done
  done

  if (( ${#EFFECTIVE_PATHS[@]} )); then
    declare -A seen_paths=()
    for src in "${EFFECTIVE_PATHS[@]}"; do
      [[ -z "$src" ]] && continue
      if [[ -n "${seen_paths[$src]:-}" ]]; then
        continue
      fi
      seen_paths[$src]=1
      local dest_rel
      dest_rel="$(path_dest_from_source "$src")"
      local display="$dest_rel"

      if [[ -d "$src" ]]; then
        local tgt="$STAGING_ROOT/$dest_rel"
        mkdir -p "$tgt"
        local rsync_out=""
        rsync_out="$(rsync "${RSYNC_FLAGS[@]}" "${EXCL[@]}" "$src/" "$tgt/" 2>&1)"
        local rsync_rc=$?
        if (( rsync_rc != 0 )); then
          warn "PATH-DIR: $src -> $display (rsync falló con código $rsync_rc)"
          if [[ -n "$rsync_out" ]]; then
            while IFS= read -r line; do log "    $line"; done <<<"$rsync_out"
          fi
          continue
        fi
        if [[ -n "$rsync_out" ]]; then
          staging_changed=1
          log "PATH-DIR: $src -> $display (cambios)"
          while IFS= read -r line; do log "    $line"; done <<<"$rsync_out"
        else
          log "PATH-DIR: $src -> $display (sin cambios)"
        fi
      elif [[ -f "$src" ]]; then
        local tgt="$STAGING_ROOT/$dest_rel"
        local parent
        parent="$(dirname "$tgt")"
        mkdir -p "$parent"
        if [[ -f "$tgt" ]] && cmp -s "$src" "$tgt"; then
          log "PATH-FILE: $src -> $display (sin cambios)"
        else
          install -D -m 0644 "$src" "$tgt"
          staging_changed=1
          log "PATH-FILE: $src -> $display (actualizado)"
        fi
      else
        warn "Ruta en paths/watch_paths no existe: $src"
      fi
    done
  fi

  log "Sync STAGING -> REPO"
  rsync "${RSYNC_FLAGS[@]}" "${EXCL[@]}" "$STAGING_ROOT/" "$REPO_HOST_ROOT/" | tee -a "$LOG_FILE" || true

  local staging_has_content=1
  if [[ -z "$(find "$STAGING_ROOT" -mindepth 1 -type f -print -quit 2>/dev/null)" ]]; then
    staging_has_content=0
  fi

  git_commit_and_push "$CFG_repo_path" "$REPO_HOST_ROOT" "$CFG_env" "$CFG_host" "$STAGING_ROOT" "$staging_changed" "$staging_has_content"

  ok "RUN completado."
  log "=== END $CFG_host ==="
}

main "$@"
