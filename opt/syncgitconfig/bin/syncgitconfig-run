#!/usr/bin/env bash
# syncgitconfig-run — ejecuta una pasada: YAML → staging → repo → commit/push
set -euo pipefail
umask 022

# Carga comunes
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=/opt/syncgitconfig/lib/common.sh
. "$SCRIPT_DIR/../lib/common.sh"

BYPASS_COOLDOWN=0
SEED_MODE=0

declare -a SRC_EFFECTIVE_TYPES=()
declare -a SRC_EFFECTIVE_STRIPS=()
declare -a SRC_EFFECTIVE_DEST_BASE=()
declare -a SRC_EFFECTIVE_TARGET_RELS=()
declare -a APP_CHANGED_FLAGS=()
RUN_TIMESTAMP=""
__README_UPDATED=0

usage() {
  cat <<'USAGE'
Uso: syncgitconfig-run [--no-cooldown] [--seed] [--once]

  --no-cooldown  Ejecuta ignorando la ventana de cooldown configurada.
  --seed         Fuerza snapshot inicial (implica --no-cooldown).
  --once         Alias de compatibilidad (no tiene efecto adicional).
USAGE
}

parse_args() {
  local unknown=()
  while (($#)); do
    case "$1" in
      --no-cooldown)
        BYPASS_COOLDOWN=1
        ;;
      --seed)
        SEED_MODE=1
        BYPASS_COOLDOWN=1
        ;;
      --once)
        # Alias de compatibilidad con versiones anteriores del wrapper/systemd
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        unknown+=("$1")
        ;;
    esac
    shift
  done

  if ((${#unknown[@]})); then
    warn "Argumentos ignorados: ${unknown[*]}"
  fi
}

dest_within_repo_or_die() {
  local dest="$1" repo_root="$2" app="$3"

  if [[ "$dest" == /* ]]; then
    err "apps[$app].dest no puede ser absoluto: $dest"
    exit 1
  fi
  if [[ "$dest" =~ (^|/)[.][.](|/|$) ]]; then
    err "apps[$app].dest contiene '..': $dest"
    exit 1
  fi

  local resolved=""
  if command -v realpath >/dev/null 2>&1; then
    resolved="$(realpath -m "$repo_root/$dest" 2>/dev/null || true)"
  elif command -v python3 >/dev/null 2>&1; then
    resolved="$(python3 - "$repo_root" "$dest" <<'PY'
import os, sys
base = sys.argv[1]
sub = sys.argv[2]
print(os.path.normpath(os.path.join(base, sub)))
PY
)"
  else
    resolved="$repo_root/$dest"
  fi

  case "$resolved" in
    "$repo_root"|"$repo_root"/*) ;;
    *)
      err "apps[$app].dest apunta fuera del repo: $dest"
      exit 1
      ;;
  esac
}

path_dest_from_source() {
  local src="$1"
  local cleaned="$src"
  if [[ "$cleaned" != "/" ]]; then
    cleaned="${cleaned%/}"
  fi
  if [[ -z "$cleaned" || "$cleaned" == "/" ]]; then
    echo "paths/root"
  else
    echo "paths${cleaned}"
  fi
}

normalize_rel_path() {
  local path="$1"
  [[ -z "$path" ]] && { echo ""; return; }
  while [[ "$path" == ./* ]]; do
    path="${path#./}"
  done
  while [[ "$path" == /* ]]; do
    path="${path#/}"
  done
  while [[ -n "$path" && "$path" != "/" && "$path" == */ ]]; do
    path="${path%/}"
  done
  [[ "$path" == "." || "$path" == "/" ]] && path=""
  echo "$path"
}

compute_dir_target_rel() {
  local src="$1" strip="$2" dest_base="$3"
  local rel="/"
  if [[ -n "$strip" && "$src" == "$strip"* ]]; then
    rel="${src#"$strip"}"
    [[ "$rel" == "/" ]] && rel=""
  fi
  local trimmed="${rel#/}"
  local base="${dest_base%/}"
  local result=""
  if [[ "$base" == "." || -z "$base" ]]; then
    result="$trimmed"
  else
    if [[ -n "$trimmed" ]]; then
      result="$base/$trimmed"
    else
      result="$base"
    fi
  fi
  normalize_rel_path "$result"
}

compute_file_target_rel() {
  local src="$1" strip="$2" dest_base="$3"
  local rel="${src#"$strip"}"
  rel="${rel#/}"
  local base="${dest_base%/}"
  local result=""
  if [[ "$base" == "." || -z "$base" ]]; then
    result="$rel"
  else
    if [[ -n "$rel" ]]; then
      result="$base/$rel"
    else
      result="$base/$(basename "$src")"
    fi
  fi
  normalize_rel_path "$result"
}

write_app_readme() {
  local app_idx="$1" app_name="$2" dest="$3" staged_app_root="$4" app_changed="$5" timestamp="$6"

  __README_UPDATED=0

  if [[ -z "$dest" || "$dest" == "." ]]; then
    return
  fi

  local readme_path="$staged_app_root/README.md"
  local last_sync_existing=""
  if [[ -f "$readme_path" ]]; then
    last_sync_existing="$(grep -E '^Última sincronización:' "$readme_path" 2>/dev/null | head -n1 | cut -d':' -f2- | sed 's/^ *//')"
  fi

  local last_sync_value="$last_sync_existing"
  if (( app_changed )); then
    last_sync_value="$timestamp"
  elif [[ -z "$last_sync_existing" ]]; then
    last_sync_value="$timestamp"
  fi

  local tmp_file
  tmp_file="$(mktemp "${TMPDIR:-/tmp}/syncgitconfig-app-readme.XXXXXX")"

  {
    printf '# %s\n\n' "$app_name"
    printf '* Destino en el repositorio: `%s`\n' "$dest"
    if [[ -n "$last_sync_value" ]]; then
      printf '* Última sincronización: %s\n\n' "$last_sync_value"
    else
      printf '* Última sincronización: pendiente\n\n'
    fi
    printf '## Orígenes sincronizados\n\n'

    local found_source=0
    for ((idx=0; idx<${#SRC_APPIDX[@]}; idx++)); do
      if (( SRC_APPIDX[idx] == app_idx )); then
        found_source=1
        local src="${SRC_PATHS[$idx]}"
        local typ="${SRC_EFFECTIVE_TYPES[$idx]:-${SRC_TYPES[$idx]}}"
        [[ -n "$typ" ]] || typ="auto"
        local strip_value="${SRC_EFFECTIVE_STRIPS[$idx]:-${SRC_STRIPS[$idx]}}"
        local strip_display="$strip_value"
        if [[ -z "$strip_display" ]]; then
          strip_display="(auto)"
        else
          strip_display="\`$strip_display\`"
        fi
        local dest_base="${SRC_EFFECTIVE_DEST_BASE[$idx]:-$dest}"
        [[ -n "$dest_base" ]] || dest_base="$dest"
        local target_display="${SRC_EFFECTIVE_TARGET_RELS[$idx]:-}"
        if [[ -n "$target_display" ]]; then
          target_display="\`$target_display\`"
        else
          if [[ -n "$dest_base" && "$dest_base" != "." ]]; then
            target_display="\`$dest_base\`"
          elif [[ "$dest_base" == "." ]]; then
            target_display="\`.\` (raíz del repositorio)"
          else
            target_display="(carpeta del app)"
          fi
        fi
        local declared_dest="${SRC_DESTS[$idx]}"
        printf -- '- `%s`\n' "$src"
        printf '  - Tipo efectivo: %s\n' "$typ"
        printf '  - Strip aplicado: %s\n' "$strip_display"
        printf '  - Destino relativo: %s\n' "$target_display"
        if [[ -n "$declared_dest" && "$declared_dest" != "." ]]; then
          printf '  - Destino personalizado declarado: `%s`\n' "$declared_dest"
        fi
        printf '\n'
      fi
    done

    if (( ! found_source )); then
      printf '_Sin rutas declaradas._\n'
    fi
  } >"$tmp_file"

  if [[ ! -f "$readme_path" ]] || ! cmp -s "$tmp_file" "$readme_path"; then
    install -D -m 0644 "$tmp_file" "$readme_path"
    __README_UPDATED=1
  fi

  rm -f "$tmp_file"
}

main() {
  parse_args "$@"

  require_cmd rsync git install || exit 1
  load_config_yaml "$CONF_PATH"

  acquire_lock_or_exit
  respect_cooldown_or_exit

  ensure_https_token_credentials

  ensure_git_repo_ready "$CFG_repo_path" "$CFG_remote_url" "$AUTH_token_file"

  local STAGING_ROOT
  STAGING_ROOT="$(staging_root_path)"
  local REPO_HOST_ROOT
  REPO_HOST_ROOT="$(repo_host_root_path)"
  mkdir -p "$STAGING_ROOT" "$REPO_HOST_ROOT"

  RUN_TIMESTAMP="$(date +'%Y-%m-%d %H:%M:%S %Z')"
  SRC_EFFECTIVE_TYPES=()
  SRC_EFFECTIVE_STRIPS=()
  SRC_EFFECTIVE_DEST_BASE=()
  SRC_EFFECTIVE_TARGET_RELS=()
  APP_CHANGED_FLAGS=()

  local staging_changed=0

  RSYNC_FLAGS=(-a --delete --itemize-changes)
  read -r -a EXCL <<<"$(rsync_exclude_flags)"

  local -a EFFECTIVE_PATHS=()
  local -a PATH_DEST_RELS=()
  if (( ${#APP_NAMES[@]} == 0 )); then
    EFFECTIVE_PATHS=("${PATHS[@]}")
  fi
  local using_watch_paths_as_sources=0
  if (( ${#EFFECTIVE_PATHS[@]} == 0 && ${#WATCH_PATHS[@]} > 0 && ${#APP_NAMES[@]} == 0 )); then
    EFFECTIVE_PATHS=("${WATCH_PATHS[@]}")
    using_watch_paths_as_sources=1
  fi

  if (( ${#APP_NAMES[@]} == 0 && ${#EFFECTIVE_PATHS[@]} == 0 )); then
    err "No hay rutas declaradas en $CONF_PATH (bloques 'apps' o 'paths')."
    err "Define rutas bajo 'apps'/'environments' o entradas en 'paths' para poder generar snapshots."
    exit 1
  fi

  if (( using_watch_paths_as_sources )); then
    log "[INFO] Usando watch_paths como rutas a sincronizar (modo watch_paths)."
  fi

  local staging_pre_has_content=0
  if [[ -n "$(find "$STAGING_ROOT" -mindepth 1 -type f -print -quit 2>/dev/null)" ]]; then
    staging_pre_has_content=1
  fi

  local repo_has_content=0
  if [[ -n "$(find "$REPO_HOST_ROOT" -mindepth 1 -type f -print -quit 2>/dev/null)" ]]; then
    repo_has_content=1
  fi

  local initial_snapshot=0
  if (( staging_pre_has_content == 0 && repo_has_content == 0 )); then
    initial_snapshot=1
  fi
  if (( SEED_MODE )); then
    initial_snapshot=1
  fi

  log "=== RUN $CFG_host ($CFG_env) ==="
  log "Staging: $STAGING_ROOT"
  log "Repo:    $REPO_HOST_ROOT"

  if (( SEED_MODE )); then
    log "[INFO] Ejecutando en modo seed (--seed)."
  fi
  if (( initial_snapshot )); then
    log "[INFO] Snapshot inicial: staging y repo vacíos."
  fi

  mkdir -p "$STAGING_ROOT"

  local managed_state_file="$STAGING_ROOT/.managed_paths"
  declare -A NEW_MANAGED_DIRS=()
  declare -A NEW_MANAGED_FILES=()

  for ((i=0; i<${#APP_NAMES[@]}; i++)); do
    local app="${APP_NAMES[$i]}"
    local dest="${APP_DESTS[$i]}"
    [[ -z "$dest" ]] && dest="apps/$app"
    dest="${dest%/}"
    APP_DESTS[$i]="$dest"
    APP_CHANGED_FLAGS[$i]=0
    if [[ -n "$dest" && "$dest" != "." ]]; then
      NEW_MANAGED_DIRS["$dest"]=1
      NEW_MANAGED_FILES["$dest/README.md"]=1
    fi
  done

  for ((s=0; s<${#SRC_APPIDX[@]}; s++)); do
    local idx="${SRC_APPIDX[$s]}"
    local src="${SRC_PATHS[$s]}"
    local typ="${SRC_TYPES[$s]}"
    local strip="${SRC_STRIPS[$s]}"
    local dest_override="${SRC_DESTS[$s]}"
    local dest_base="${APP_DESTS[$idx]}"
    if [[ -n "$dest_override" ]]; then
      if [[ "$dest_override" == "." ]]; then
        dest_base="."
      else
        dest_base="${dest_override%/}"
      fi
    fi
    if [[ -n "$dest_base" && "$dest_base" != "." ]]; then
      NEW_MANAGED_DIRS["$dest_base"]=1
    fi

    local effective_type="$typ"
    local effective_strip="$strip"
    if [[ "$effective_type" == "auto" || -z "$effective_type" ]]; then
      if [[ -d "$src" ]]; then
        effective_type="dir"
        [[ -n "$effective_strip" ]] || effective_strip="$src"
      elif [[ -f "$src" ]]; then
        effective_type="file"
        [[ -n "$effective_strip" ]] || effective_strip="$(dirname "$src")"
      else
        effective_type="unknown"
      fi
    else
      if [[ "$effective_type" == "dir" && -z "$effective_strip" ]]; then
        effective_strip="$src"
      elif [[ "$effective_type" == "file" && -z "$effective_strip" ]]; then
        effective_strip="$(dirname "$src")"
      fi
    fi

    local target_rel=""
    if [[ "$effective_type" == "dir" ]]; then
      target_rel="$(compute_dir_target_rel "$src" "$effective_strip" "$dest_base")"
      if [[ -n "$target_rel" ]]; then
        NEW_MANAGED_DIRS["$target_rel"]=1
      fi
    elif [[ "$effective_type" == "file" ]]; then
      target_rel="$(compute_file_target_rel "$src" "$effective_strip" "$dest_base")"
      if [[ -n "$target_rel" ]]; then
        NEW_MANAGED_FILES["$target_rel"]=1
      fi
    fi

    SRC_EFFECTIVE_TYPES[$s]="$effective_type"
    SRC_EFFECTIVE_STRIPS[$s]="$effective_strip"
    SRC_EFFECTIVE_DEST_BASE[$s]="$dest_base"
    SRC_EFFECTIVE_TARGET_RELS[$s]="$target_rel"
  done

  PATH_DEST_RELS=()
  if (( ${#EFFECTIVE_PATHS[@]} )); then
    for ((p=0; p<${#EFFECTIVE_PATHS[@]}; p++)); do
      local src_path="${EFFECTIVE_PATHS[$p]}"
      local dest_rel
      dest_rel="$(normalize_rel_path "$(path_dest_from_source "$src_path")")"
      PATH_DEST_RELS[$p]="$dest_rel"
      [[ -z "$dest_rel" ]] && continue
      if [[ -d "$src_path" ]]; then
        NEW_MANAGED_DIRS["$dest_rel"]=1
      elif [[ -f "$src_path" ]]; then
        NEW_MANAGED_FILES["$dest_rel"]=1
      else
        NEW_MANAGED_DIRS["$dest_rel"]=1
      fi
    done
  fi

  declare -A OLD_MANAGED_DIRS=()
  declare -A OLD_MANAGED_FILES=()
  if [[ -f "$managed_state_file" ]]; then
    while IFS=$'\t' read -r kind path; do
      [[ -z "$kind" || -z "$path" ]] && continue
      if [[ "$kind" == "D" ]]; then
        OLD_MANAGED_DIRS["$path"]=1
      elif [[ "$kind" == "F" ]]; then
        OLD_MANAGED_FILES["$path"]=1
      fi
    done <"$managed_state_file"
  fi

  for path in "${!OLD_MANAGED_DIRS[@]}"; do
    if [[ -z "${NEW_MANAGED_DIRS[$path]:-}" ]]; then
      local target="$STAGING_ROOT/$path"
      if [[ -e "$target" || -L "$target" ]]; then
        log "[INFO] Eliminando directorio obsoleto de staging: $path"
        rm -rf "$target"
        staging_changed=1
      fi
    fi
  done
  for path in "${!OLD_MANAGED_FILES[@]}"; do
    if [[ -z "${NEW_MANAGED_FILES[$path]:-}" ]]; then
      local target="$STAGING_ROOT/$path"
      if [[ -e "$target" || -L "$target" ]]; then
        log "[INFO] Eliminando fichero obsoleto de staging: $path"
        rm -f "$target"
        staging_changed=1
      fi
    fi
  done

  for ((i=0; i<${#APP_NAMES[@]}; i++)); do
    local app="${APP_NAMES[$i]}" dest="${APP_DESTS[$i]}"
    [[ -z "$dest" ]] && dest="apps/$app"
    APP_DESTS[$i]="$dest"
    dest_within_repo_or_die "$dest" "$REPO_HOST_ROOT" "$app"
    local staged_app_root="$STAGING_ROOT/$dest"
    mkdir -p "$staged_app_root"

    for ((s=0; s<${#SRC_APPIDX[@]}; s++)); do
      if (( SRC_APPIDX[$s] == i )); then
        local src="${SRC_PATHS[$s]}" typ="${SRC_TYPES[$s]}" strip="${SRC_STRIPS[$s]}"
        local dest_override="${SRC_DESTS[$s]}"
        local effective_type="$typ"
        local effective_strip="$strip"

        if [[ "$effective_type" == "auto" || -z "$effective_type" ]]; then
          if [[ -d "$src" ]]; then
            effective_type="dir"
            [[ -n "$effective_strip" ]] || effective_strip="$src"
          elif [[ -f "$src" ]]; then
            effective_type="file"
            [[ -n "$effective_strip" ]] || effective_strip="$(dirname "$src")"
          else
            warn "Ruta no existe: $src"
            continue
          fi
        fi

        local dest_base="$dest"
        if [[ -n "$dest_override" ]]; then
          dest_within_repo_or_die "$dest_override" "$REPO_HOST_ROOT" "$app"
          if [[ "$dest_override" == "." ]]; then
            dest_base="$dest_override"
          else
            dest_base="${dest_override%/}"
          fi
        fi
        local staged_base="$STAGING_ROOT/$dest_base"
        mkdir -p "$staged_base"

        if [[ "$effective_type" == "dir" ]]; then
          if [[ -d "$src" ]]; then
            local rel="/"
            if [[ "$src" == "$effective_strip"* ]]; then
              rel="${src#"$effective_strip"}"; [[ "$rel" == "/" ]] && rel=""
            fi
            local tgt="$staged_base/${rel#/}"
            mkdir -p "$tgt"
            local display="$dest_base"
            [[ -n "${rel#/}" ]] && display="$dest_base/${rel#/}"
            local rsync_out=""
            rsync_out="$(rsync "${RSYNC_FLAGS[@]}" "${EXCL[@]}" "$src/" "$tgt/" 2>&1)"
            local rsync_rc=$?
            if (( rsync_rc != 0 )); then
              warn "DIR: $src -> $display (rsync falló con código $rsync_rc)"
              if [[ -n "$rsync_out" ]]; then
                while IFS= read -r line; do log "    $line"; done <<<"$rsync_out"
              fi
              continue
            fi
            if [[ -n "$rsync_out" ]]; then
              staging_changed=1
              APP_CHANGED_FLAGS[$i]=1
              log "DIR: $src -> $display (cambios)"
              while IFS= read -r line; do log "    $line"; done <<<"$rsync_out"
            else
              log "DIR: $src -> $display (sin cambios)"
            fi
          else
            warn "Directorio no existe: $src"
          fi
        elif [[ "$effective_type" == "file" ]]; then
          if [[ -f "$src" ]]; then
            local rel="${src#"$effective_strip"}"; rel="${rel#/}"
            local tgt="$staged_base/$rel"
            local display="$dest_base"
            [[ -n "$rel" ]] && display="$dest_base/$rel"
            if [[ -f "$tgt" ]] && cmp -s "$src" "$tgt"; then
              log "FILE: $src -> $display (sin cambios)"
            else
              install -D -m 0644 "$src" "$tgt"
              staging_changed=1
              APP_CHANGED_FLAGS[$i]=1
              log "FILE: $src -> $display (actualizado)"
            fi
          else
            warn "Fichero no existe: $src"
          fi
        else
          warn "Tipo de source desconocido '$typ' en app '$app'"
        fi
      fi
    done

    write_app_readme "$i" "$app" "$dest" "$staged_app_root" "${APP_CHANGED_FLAGS[$i]:-0}" "$RUN_TIMESTAMP"
    if (( __README_UPDATED )); then
      staging_changed=1
      APP_CHANGED_FLAGS[$i]=1
    fi
  done

  if (( ${#EFFECTIVE_PATHS[@]} )); then
    declare -A seen_paths=()
    for ((p=0; p<${#EFFECTIVE_PATHS[@]}; p++)); do
      local src="${EFFECTIVE_PATHS[$p]}"
      [[ -z "$src" ]] && continue
      if [[ -n "${seen_paths[$src]:-}" ]]; then
        continue
      fi
      seen_paths[$src]=1
      local dest_rel="${PATH_DEST_RELS[$p]}"
      [[ -n "$dest_rel" ]] || dest_rel="$(normalize_rel_path "$(path_dest_from_source "$src")")"
      local display="$dest_rel"

      if [[ -d "$src" ]]; then
        local tgt="$STAGING_ROOT/$dest_rel"
        mkdir -p "$tgt"
        local rsync_out=""
        rsync_out="$(rsync "${RSYNC_FLAGS[@]}" "${EXCL[@]}" "$src/" "$tgt/" 2>&1)"
        local rsync_rc=$?
        if (( rsync_rc != 0 )); then
          warn "PATH-DIR: $src -> $display (rsync falló con código $rsync_rc)"
          if [[ -n "$rsync_out" ]]; then
            while IFS= read -r line; do log "    $line"; done <<<"$rsync_out"
          fi
          continue
        fi
        if [[ -n "$rsync_out" ]]; then
          staging_changed=1
          log "PATH-DIR: $src -> $display (cambios)"
          while IFS= read -r line; do log "    $line"; done <<<"$rsync_out"
        else
          log "PATH-DIR: $src -> $display (sin cambios)"
        fi
      elif [[ -f "$src" ]]; then
        local tgt="$STAGING_ROOT/$dest_rel"
        local parent
        parent="$(dirname "$tgt")"
        mkdir -p "$parent"
        if [[ -f "$tgt" ]] && cmp -s "$src" "$tgt"; then
          log "PATH-FILE: $src -> $display (sin cambios)"
        else
          install -D -m 0644 "$src" "$tgt"
          staging_changed=1
          log "PATH-FILE: $src -> $display (actualizado)"
        fi
      else
        warn "Ruta en paths/watch_paths no existe: $src"
      fi
    done
  fi

  if (( ${#NEW_MANAGED_DIRS[@]} || ${#NEW_MANAGED_FILES[@]} )); then
    local tmp_manifest
    tmp_manifest="${managed_state_file}.tmp"
    {
      for dir in "${!NEW_MANAGED_DIRS[@]}"; do
        [[ -z "$dir" ]] && continue
        printf 'D\t%s\n' "$dir"
      done
      for file in "${!NEW_MANAGED_FILES[@]}"; do
        [[ -z "$file" ]] && continue
        printf 'F\t%s\n' "$file"
      done
    } | sort >"$tmp_manifest"
    mv "$tmp_manifest" "$managed_state_file"
  else
    rm -f "$managed_state_file"
  fi

  log "Sync STAGING -> REPO"
  rsync "${RSYNC_FLAGS[@]}" "${EXCL[@]}" "$STAGING_ROOT/" "$REPO_HOST_ROOT/" | tee -a "$LOG_FILE" || true

  local staging_has_content=1
  if [[ -z "$(find "$STAGING_ROOT" -mindepth 1 -type f -print -quit 2>/dev/null)" ]]; then
    staging_has_content=0
  fi

  local app_tag=""
  if (( ${#APP_NAMES[@]} )); then
    local changed_total=0
    local -a changed_preview=()
    for ((i=0; i<${#APP_NAMES[@]}; i++)); do
      if (( ${APP_CHANGED_FLAGS[$i]:-0} )); then
        ((++changed_total))
        if (( ${#changed_preview[@]} < 3 )); then
          local slug
          slug="$(slugify_app_tag "${APP_NAMES[$i]}")"
          if [[ -z "$slug" ]]; then
            slug="app$changed_total"
          fi
          changed_preview+=("$slug")
        fi
      fi
    done
    if (( changed_total )); then
      if (( changed_total > 3 )); then
        changed_preview+=("mas$((changed_total - 3))")
      fi
      local IFS='+'
      app_tag="${changed_preview[*]}"
    fi
  fi

  git_commit_and_push "$CFG_repo_path" "$REPO_HOST_ROOT" "$CFG_env" "$CFG_host" "$STAGING_ROOT" "$staging_changed" "$staging_has_content" "$app_tag"

  ok "RUN completado."
  log "=== END $CFG_host ==="
}

main "$@"
