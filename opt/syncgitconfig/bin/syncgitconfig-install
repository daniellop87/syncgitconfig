#!/usr/bin/env bash
# syncgitconfig-install — bootstrap/instalación y primera ejecución
set -euo pipefail
umask 022

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=/opt/syncgitconfig/lib/common.sh
. "$SCRIPT_DIR/../lib/common.sh"

install_pkgs_if_possible() {
  # Intenta instalar lo básico si hay gestor de paquetes disponible
  if command -v apt-get >/dev/null 2>&1; then
    apt-get update -y || true
    DEBIAN_FRONTEND=noninteractive apt-get install -y git rsync inotify-tools ca-certificates || true
  elif command -v dnf >/dev/null 2>&1; then
    dnf install -y git rsync inotify-tools ca-certificates || true
  elif command -v yum >/dev/null 2>&1; then
    yum install -y git rsync inotify-tools ca-certificates || true
  elif command -v zypper >/dev/null 2>&1; then
    zypper --non-interactive install git rsync inotify-tools ca-certificates || true
  fi
}

ensure_units_present() {
  # Deja plantillas mínimas si faltan (por si no se desplegaron con Ansible)
  local svc1="/etc/systemd/system/syncgitconfig.service"
  local svc2="/etc/systemd/system/syncgitconfig-watch.service"
  if [[ ! -f "$svc1" ]]; then
cat > "$svc1" <<'UNIT'
[Unit]
Description=syncgitconfig one-shot run
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/opt/syncgitconfig/bin/syncgitconfig-run

[Install]
WantedBy=multi-user.target
UNIT
  fi
  if [[ ! -f "$svc2" ]]; then
cat > "$svc2" <<'UNIT'
[Unit]
Description=syncgitconfig watcher (inotify)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=/opt/syncgitconfig/bin/syncgitconfig-watch
Restart=always
RestartSec=5
User=root

[Install]
WantedBy=multi-user.target
UNIT
  fi
}

migrate_token_inline_to_credentials() {
  # Si token_inline existe en YAML, construye entrada en token_file y lo "redacta" del YAML
  if [[ -z "$AUTH_token_inline" ]]; then
    return
  fi

  if [[ "$AUTH_effective_method" != "https_token" ]]; then
    warn "token_inline definido pero auth.method no es https_token; se omite migración."
    return
  fi

  [[ -n "$AUTH_username" ]] || AUTH_username="token"
  [[ -n "$AUTH_token_file" ]] || AUTH_token_file="/etc/syncgitconfig/credentials/.git-credentials"
  mkdir -p "$(dirname "$AUTH_token_file")"; chmod 700 "$(dirname "$AUTH_token_file")" || true

  local url="$CFG_remote_url"
  if [[ "$url" != https://* && "$url" != http://* ]]; then
    warn "token_inline definido pero remote_url no es HTTPS: $url"
    return
  fi

  local rest="$url"
  rest="${rest#http://}"
  rest="${rest#https://}"
  echo "https://${AUTH_username}:${AUTH_token_inline}@${rest}" > "$AUTH_token_file"
  chmod 600 "$AUTH_token_file"

  git config --global credential.helper "store --file=$AUTH_token_file" || true

  sed -i 's/^\(\s*token_inline:\s*\).*/\1"REDACTED"/' "$CONF_PATH" || true
  ok "Token migrado a $AUTH_token_file y redactado en YAML."
}

clone_repo_if_missing() {
  local rp="$CFG_repo_path" url="$CFG_remote_url"
  mkdir -p "$rp"
  if [[ ! -d "$rp/.git" ]]; then
    local display="$(redact_remote_url "$url")"
    log "Clonando repo $display en $rp"
    if ! run_git clone "$url" "$rp"; then
      err "git clone falló para $display"
      exit 1
    fi
  fi
  ok "Repo listo en $rp"
}

main() {
  require_cmd bash sed awk grep install || exit 1
  install_pkgs_if_possible
  require_cmd git rsync inotifywait || { err "Instala git rsync inotify-tools"; exit 1; }

  load_config_yaml "$CONF_PATH"

  migrate_token_inline_to_credentials
  clone_repo_if_missing

  ensure_units_present
  systemctl daemon-reload || true
  systemctl enable --now syncgitconfig-watch.service || true

  # Primera pasada manual
  /opt/syncgitconfig/bin/syncgitconfig-run || true

  ok "Instalación completada."
}

main "$@"
